module Main where
--https://github.com/digital-asset/certification-damlfundamentals-capstone

import Daml.Script

type BankAccountKey =(Party,Text)
data BankDetails= BankDetails
  with
    bankName : Text
    address : Text
  
    -- Custom implementation of Show for BankDetails
instance Show BankDetails where
      show bd =
        "Bank Name: " <> bd.bankName <>
        "\nAddress: " <> bd.address

    -- Custom implementation of Eq for BankDetails
instance Eq BankDetails where
      (==) bd1 bd2 =
        bd1.bankName == bd2.bankName &&
       bd1.address == bd2.address


template Account
  with
    accountNumber : Text
    owner : Party
    balance : Int
    bank:BankDetails
  where
    signatory owner
    observer owner
   

    key (owner,accountNumber) : BankAccountKey
    maintainer key._1

    choice Transfer : ContractId Account
      with
        recipient : Party
        amount : Int
        bankdet : BankDetails
        accno: Text
      controller owner,recipient
      do
        assertMsg "Amount must be greater than 0" (amount > 0) 
        assertMsg "Insufficient balance" (balance >= amount) 
        let updatedBalance = balance - amount
        create Account with accountNumber = accno, owner = recipient, balance = amount,bank=bankdet
       -- create Account with accountNumber=this.accountNumber,owner=owner,balance=updatedBalance,bank=bankdet
    nonconsuming choice GetBalance : Int
      controller owner
      do
        return balance

    choice Deposit : ContractId Account
      with
        amount : Int

      controller owner
      do
        assertMsg "Amount must be greater than 0" (amount > 0) 
        let updatedBalance = balance + amount
        create Account with accountNumber = accountNumber, owner = owner, balance = updatedBalance,bank=bank
    
    nonconsuming choice GetCustomer : (ContractId Account,Account)
     with
       accno : Text
      controller owner
     do
       fetchByKey @Account (owner,accno)

type CustomerId =(Party,Text)

template Customer
  with
    customer : Party
    name : Text
    address : Text
  where
    signatory customer 
    
    key (customer,name) : CustomerId
    maintainer key._1

    choice CreateCustomer : ContractId Customer
        with
          customer : Party
          cname:Text
          address:Text
        controller customer
        do
          create Customer with customer=customer,  name = cname, address = address

testScript : Script ()
testScript = do
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  let  bankdetails = BankDetails{

    bankName="abcco",
    address="abc street"
  }

  --positive cases
  --create an account
  aliceCid<- submit alice do
    createCmd Account with accountNumber="001",owner=alice,balance=60,bank=bankdetails
  Some c <- queryContractId alice aliceCid
  assert $ c.accountNumber == "001"

  --reterive balance
  balance <- submit alice do
    exerciseCmd aliceCid GetBalance
  assert $ balance == 60
  
  --update the balance
  alicenewCid<-submit alice do
    exerciseCmd aliceCid Deposit with amount=75
  balance <- submit alice do
    exerciseCmd alicenewCid GetBalance
  assert $ balance == 135

  -- Transfer funds
 -- bobCid<-submitMulti[alice,bob][] do
  --  exerciseCmd alicenewCid Transfer with accno="002",recipient=bob,amount=60,bankdet=bankdetails
  --Some c <- queryContractId alice aliceCid
  --negative cases



  return()
